<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Roguelike Dungeon Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #gameContainer {
            display: flex;
            gap: 20px;
            position: relative;
        }

        #dungeon {
            background: #000;
            border: 2px solid #444;
            position: relative;
        }

        #sidebar {
            width: 300px;
            background: #222;
            border: 2px solid #444;
            padding: 15px;
            border-radius: 5px;
            height: 600px;
            overflow-y: auto;
            box-sizing: border-box;
        }

        button {
            background: #444;
            color: #fff;
            border: 1px solid #666;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        button:hover {
            background: #555;
        }

        h2 {
            margin-top: 0;
            color: #ffaa00;
        }

        .stats {
            margin-bottom: 15px;
        }

        .stat {
            margin: 5px 0;
        }

        #inventorySection {
            margin-bottom: 20px;
        }

        #inventorySection h2 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #ffaa00;
        }

        #statsSection {
            margin-bottom: 20px;
        }

        #statsSection h2 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #ffaa00;
        }

        .sidebar-toggle-hint {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .inv-section {
            margin-bottom: 12px;
        }

        .inv-section h4 {
            margin: 6px 0 4px;
            color: #ffcc33;
        }

        .inv-item-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            background: #2d2d2d;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 14px;
        }

        .inv-item-row + .inv-item-row {
            margin-top: 4px;
        }

        .inv-actions button {
            padding: 2px 6px;
            font-size: 12px;
        }

        .tag {
            background: #444;
            border-radius: 3px;
            padding: 1px 4px;
            font-size: 11px;
            color: #ccc;
        }

        .close-hint {
            font-size: 12px;
            color: #aaa;
            margin-top: 6px;
        }

        .equipped-section {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 15px;
        }

        .equipped-section h4 {
            margin: 0 0 8px 0;
            color: #88ff88;
            font-size: 14px;
        }

        .equipped-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 4px;
            font-size: 13px;
        }

        .equipped-slot {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #2a2a2a;
            padding: 3px 6px;
            border-radius: 3px;
            border-left: 3px solid #444;
        }

        .equipped-slot.has-item {
            border-left-color: #88ff88;
        }

        .slot-label {
            color: #ccc;
            font-weight: bold;
            min-width: 50px;
        }

        .slot-item {
            color: #fff;
            flex: 1;
            text-align: right;
        }

        .slot-empty {
            color: #666;
            font-style: italic;
        }

        .slot-actions {
            margin-left: 6px;
        }

        .slot-actions button {
            padding: 2px 4px;
            font-size: 10px;
            background: #555;
            border: 1px solid #777;
            color: #fff;
            border-radius: 2px;
            cursor: pointer;
        }

        .slot-actions button:hover {
            background: #666;
        }
    </style>
    <script src="monster.js"></script>
    <script src="player.js"></script>
    <script src="items.js"></script>
    <script src="maze.js"></script>
</head>
<body>
<h1>Roguelike Dungeon Adventure</h1>
<div id="gameContainer">
    <canvas id="dungeon" width="800" height="600"></canvas>
    <div id="sidebar">
        <div class="sidebar-toggle-hint">Press / to toggle view</div>
        <div id="inventorySection">
            <h2>Inventory</h2>
            <div id="inventoryContents"></div>
        </div>
        <div id="statsSection" style="display: none;">
            <h2>Player Stats</h2>
            <div class="stats">
                <div class="stat">Level: <span id="level">1</span></div>
                <div class="stat">Health: <span id="health">100</span></div>
                <div class="stat">Gold: <span id="gold">0</span></div>
            </div>
        </div>
        <div id="messages"
             style="margin-top: 15px; height: 160px; overflow-y: auto; background: #111; padding: 5px; border-radius: 3px;">
            <div>Welcome to the dungeon!</div>
        </div>
    </div>
</div>
<script>
    class TimeManager {
        constructor(game) {
            this.game = game;
            this.futureEvents = {};
        }

        scheduleEvent(ticksFromNow, object, callback) {
            const execTick = this.game.currentTick + ticksFromNow;
            if (!this.futureEvents[execTick]) this.futureEvents[execTick] = [];
            const anEvent = {object: callback};
            this.futureEvents[execTick].push(anEvent);
        }

        advanceTime() {
            this.game.currentTick++;
            this.game.monsterManager.processTimeIncrement();
            if (Game.player.nextFreeHealTime <= this.game.currentTick) {
                Game.player.nextFreeHealTime = this.game.currentTick + 3000;
                Game.player.heal(5);
            }
            if (this.futureEvents[this.game.currentTick]) {
                const events = this.futureEvents[this.game.currentTick];
                delete this.futureEvents[this.game.currentTick];
                events.forEach(cb => cb.object(this.game));
            }
        }
    }

    class Game {
        constructor() {
            Game.player = new Player(this, 0, 0);
            this.canvas = document.getElementById('dungeon');
            this.ctx = this.canvas.getContext('2d');
            this.tileSize = 20;
            this.width = Math.floor(this.canvas.width / this.tileSize);
            this.height = Math.floor(this.canvas.height / this.tileSize);
            this.dungeon = [];
            this.rooms = [];
            this.upStair = null;
            this.downStair = null;
            this.explored = [];
            this.visible = [];
            this.levelCache = {};
            this.gameOver = false;
            this.currentTick = 0;
            this.dungeonLevel = 1;
            this.timeManager = new TimeManager(this);
            this.monsterManager = new MonsterManager(this);
            this.itemManager = new ItemManager(this);
            this.sidebarShowingInventory = true; // Track which view is active
            // Examine / Inspect mode state
            this.examineMode = false;
            this.examineCursor = null; // {x,y}
            // Running state
            this.running = false;
            this.runDirection = null;
            this.generateDungeon();
            this.monsterManager.spawnMonsters();
            this.itemManager.generateItems();
            this.computeFOV();
            this.setupEventListeners();
            this.render();
            this.updateUI();
            this.buildInventory();
        }

        // --- Shadow Casting FOV (more efficient) ---
        computeFOV(radius = 8) {
            if (!this.visible || !this.explored) {
                this.visible = Array(this.height).fill().map(() => Array(this.width).fill(false));
                this.explored = Array(this.height).fill().map(() => Array(this.width).fill(false));
            }
            for (let y = 0; y < this.height; y++) {
                for (let x = 0; x < this.width; x++) {
                    this.visible[y][x] = false;
                }
            }
            const px = Game.player.x, py = Game.player.y;
            this.visible[py][px] = true;
            this.explored[py][px] = true;
            for (let octant = 0; octant < 8; octant++) {
                this.castShadow(px, py, 1, 1.0, 0.0, radius, octant);
            }
            this.itemManager.updateItemMemory();
        }

        castShadow(cx, cy, row, start, end, radius, octant) {
            if (start < end) return;
            const radiusSquared = radius * radius;
            for (let currentRow = row; currentRow <= radius; currentRow++) {
                let dx = -currentRow - 1;
                let dy = -currentRow;
                let blocked = false;
                let newStart = 0;
                while (dx <= 0) {
                    dx++;
                    const [mx, my] = this.transformOctant(cx, cy, dx, dy, octant);
                    if (!this.inBounds(mx, my)) continue;
                    const leftSlope = (dx - 0.5) / (dy + 0.5);
                    const rightSlope = (dx + 0.5) / (dy - 0.5);
                    if (start < rightSlope) continue;
                    if (end > leftSlope) break;
                    if (dx * dx + dy * dy <= radiusSquared) {
                        this.visible[my][mx] = true;
                        this.explored[my][mx] = true;
                    }
                    if (blocked) {
                        if (this.isOpaque(mx, my)) {
                            newStart = rightSlope;
                            continue;
                        } else {
                            blocked = false;
                            start = newStart;
                        }
                    } else {
                        if (this.isOpaque(mx, my) && currentRow < radius) {
                            blocked = true;
                            this.castShadow(cx, cy, currentRow + 1, start, leftSlope, radius, octant);
                            newStart = rightSlope;
                        }
                    }
                }
                if (blocked) break;
            }
        }

        transformOctant(cx, cy, dx, dy, octant) {
            switch (octant) {
                case 0:
                    return [cx + dx, cy - dy];
                case 1:
                    return [cx + dy, cy - dx];
                case 2:
                    return [cx - dy, cy - dx];
                case 3:
                    return [cx - dx, cy - dy];
                case 4:
                    return [cx - dx, cy + dy];
                case 5:
                    return [cx - dy, cy + dx];
                case 6:
                    return [cx + dy, cy + dx];
                case 7:
                    return [cx + dx, cy + dy];
                default:
                    return [cx, cy];
            }
        }

        isOpaque(x, y) {
            if (!this.inBounds(x, y)) return true;
            const tile = this.dungeon[y][x];
            return tile === '#' || tile === '+';
        }

        descend() {
            if (this.gameOver) return;
            this.dungeonLevel += 1;
            if (this.levelCache[this.dungeonLevel]) {
                this.addMessage(`You return to level ${this.dungeonLevel}.`);
            } else {
                this.generateDungeon();
                this.monsterManager.spawnMonsters();
                this.itemManager.generateItems();
                if (this.upStair) {
                    Game.player.x = this.upStair.x;
                    Game.player.y = this.upStair.y;
                }
                this.computeFOV();
                this.addMessage(`You discover new level ${this.dungeonLevel}.`);
            }
            this.computeFOV();
            this.render();
            this.updateUI();
        }

        ascend() {
            if (this.gameOver) return;
            if (this.dungeonLevel === 1) {
                this.addMessage('You are already at the top.');
                return;
            }
            this.dungeonLevel -= 1;
            if (this.downStair) {
                Game.player.x = this.downStair.x;
                Game.player.y = this.downStair.y;
            }
            this.computeFOV();
            this.render();
            this.updateUI();
            this.addMessage(`You return to level ${this.dungeonLevel}.`);
        }

        generateDungeon() {
            this.itemManager = new ItemManager(this);
            this.monsterManager = new MonsterManager(this);
            this.explored = Array(this.height).fill().map(() => Array(this.width).fill(false));
            this.visible = Array(this.height).fill().map(() => Array(this.width).fill(false));

            const mazeGenerator = new MazeGenerator(this.width, this.height);
            const result = mazeGenerator.generateDungeon();

            this.dungeon = result.dungeon;
            this.rooms = result.rooms;
            this.upStair = result.upStair;
            this.downStair = result.downStair;

            if (this.rooms.length && !this.levelCache[this.dungeonLevel]) {
                const r = this.rooms[0];
                Game.player.x = r.x + Math.floor(r.width / 2);
                Game.player.y = r.y + Math.floor(r.height / 2);
            }
        }

        inBounds(x, y) {
            return x >= 0 && y >= 0 && x < this.width && y < this.height;
        }

        getWalkableDirections(x, y) {
            const directions = [
                {dx: 0, dy: -1}, // Up
                {dx: 0, dy: 1},  // Down
                {dx: -1, dy: 0}, // Left
                {dx: 1, dy: 0},  // Right
            ];

            return directions.filter(dir => {
                const newX = x + dir.dx;
                const newY = y + dir.dy;
                return this.inBounds(newX, newY) &&
                    this.dungeon[newY][newX] !== '#' &&
                    this.dungeon[newY][newX] !== '+';
            });
        }

        async runInDirection(dx, dy) {
            if (this.gameOver) return;

            this.running = true;
            this.runDirection = {dx, dy};

            while (this.running) {
                const newX = Game.player.x + dx;
                const newY = Game.player.y + dy;

                // Stop if we hit a wall or go out of bounds
                if (!this.inBounds(newX, newY) || this.dungeon[newY][newX] === '#') {
                    this.running = false;
                    break;
                }

                // Stop if there's a monster in the next position
                if (this.monsterManager.monsters.some(m => m.x === newX && m.y === newY)) {
                    this.running = false;
                    break;
                }

                // Stop at doors or stairs
                const tile = this.dungeon[newY][newX];
                if (tile === '+' || tile === '/' || tile === '<' || tile === '>') {
                    this.running = false;
                    break;
                }

                if (this.isValidMove(newX, newY)) {
                    Game.player.x = newX;
                    Game.player.y = newY;
                    const foundItem = this.itemManager.checkForItems();
                    if (foundItem) this.running = false;
                }
                this.render();

                // Small delay to make running visible but fast
                await this.sleep(100);

                // Consume a turn for each step
                this.consumeTurn(Game.player.speed);

                // In open rooms, continue running in the same direction
                // Only stop if we can't continue in the current direction
                const nextX = Game.player.x + dx;
                const nextY = Game.player.y + dy;

                // Stop if the next tile in our direction is blocked
                if (!this.inBounds(nextX, nextY) ||
                    this.dungeon[nextY][nextX] === '#' ||
                    this.dungeon[nextY][nextX] === '+') {
                    this.running = false;
                    break;
                }

                // Check if we're in a narrow corridor and need to handle turns
                const walkableDirections = this.getWalkableDirections(Game.player.x, Game.player.y);

                // If we're in a corridor (2 or fewer walkable directions), handle corridor logic
                if (walkableDirections.length <= 2) {
                    if (walkableDirections.length === 2) {
                        // Find the direction that's not backwards
                        const backwards = {dx: -dx, dy: -dy};
                        const forward = walkableDirections.find(dir =>
                            !(dir.dx === backwards.dx && dir.dy === backwards.dy)
                        );

                        if (forward) {
                            dx = forward.dx;
                            dy = forward.dy;
                        } else {
                            // Dead end
                            this.running = false;
                            break;
                        }
                    } else if (walkableDirections.length === 1) {
                        // Dead end
                        this.running = false;
                        break;
                    }
                }
                // If walkableDirections.length > 2, we're in an open room
                // Just continue in the same direction (dx, dy remain unchanged)
            }
        }

        setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                if (this.gameOver) return;
                const k = e.key.toLowerCase();
                const shiftHeld = e.shiftKey;

                // Examine mode key handling (non-turn consuming)
                if (this.examineMode) {
                    let dx = 0, dy = 0;
                    switch (k) {
                        case 'arrowup':
                        case 'k':
                            dy = -1;
                            break;
                        case 'arrowdown':
                        case 'j':
                            dy = 1;
                            break;
                        case 'arrowleft':
                        case 'h':
                            dx = -1;
                            break;
                        case 'arrowright':
                        case 'l':
                            dx = 1;
                            break;
                        case 'y':
                            dx = -1;
                            dy = -1;
                            break;
                        case 'u':
                            dx = 1;
                            dy = -1;
                            break;
                        case 'b':
                            dx = -1;
                            dy = 1;
                            break;
                        case 'n':
                            dx = 1;
                            dy = 1;
                            break;
                        case 'enter':
                            this.describeAt(this.examineCursor.x, this.examineCursor.y, true);
                            return;
                        case 'x': // toggle exit
                        case 'escape':
                            this.exitExamineMode();
                            return;
                        default:
                            return;
                    }
                    if (dx || dy) {
                        this.moveExamineCursor(dx, dy);
                        e.preventDefault();
                    }
                    return; // Prevent normal mode handling while examining
                }

                let dx = 0, dy = 0;
                switch (k) {
                    // Movement and actions
                    case 'arrowup':
                        dy = -1;
                        break;
                    case 'arrowdown':
                        dy = 1;
                        break;
                    case 'arrowleft':
                        dx = -1;
                        break;
                    case 'arrowright':
                        dx = 1;
                        break;
                    case 'h':
                        dx = -1;
                        break;
                    case 'j':
                        dy = 1;
                        break;
                    case 'k':
                        dy = -1;
                        break;
                    case 'l':
                        dx = 1;
                        break;
                    case 'y':
                        dx = -1;
                        dy = -1;
                        break;
                    case 'u':
                        dx = 1;
                        dy = -1;
                        break;
                    case 'b':
                        dx = -1;
                        dy = 1;
                        break;
                    case 'n':
                        dx = 1;
                        dy = 1;
                        break;
                    case '>':
                        this.useDownStairs();
                        return;
                    case '<':
                        this.useUpStairs();
                        return;
                    case 'o':
                        this.openAdjacentDoors();
                        return;
                    case 'c':
                        this.closeAdjacentDoors();
                        return;

                    case 'p':
                        Game.player.drinkPotion(this);
                        return;
                    case 'r':
                        Game.player.castScroll(this);
                        return;
                    case '/':
                        this.toggleSidebarView();
                        return;
                    case 'x':
                        this.startExamineMode();
                        return; // Enter examine mode
                    default:
                        return;
                }
                if (dx || dy) {
                    if (shiftHeld) {
                        this.runInDirection(dx, dy);
                    } else {
                        this.handleMove(dx, dy);
                    }
                    e.preventDefault();
                }
            });
        }

        startExamineMode() {
            this.examineMode = true;
            this.examineCursor = {x: Game.player.x, y: Game.player.y};
            this.addMessage('Examine: move cursor with movement keys, Enter to inspect, Esc/X to exit.');
            this.render();
        }

        exitExamineMode() {
            this.examineMode = false;
            this.examineCursor = null;
            this.addMessage('Examine mode ended.');
            this.render();
        }

        moveExamineCursor(dx, dy) {
            if (!this.examineCursor) return;
            const nx = this.examineCursor.x + dx;
            const ny = this.examineCursor.y + dy;
            if (!this.inBounds(nx, ny)) return;
            if (!this.explored[ny][nx]) return; // keep cursor within explored
            this.examineCursor.x = nx;
            this.examineCursor.y = ny;
            // Auto-describe on move (lightweight)
            this.describeAt(nx, ny, false);
            this.render();
        }

        describeAt(x, y, verbose = false) {
            if (!this.inBounds(x, y)) {
                this.addMessage('Out of bounds.');
                return;
            }
            if (!this.explored[y][x]) {
                this.addMessage('Unexplored darkness.');
                return;
            }
            // Monster first (if visible)
            const monster = this.monsterManager.monsters.find(m => m.x === x && m.y === y && this.visible[m.y] && this.visible[m.y][m.x]);
            if (monster) {
                this.addMessage(`${monster.getDisplayName()}: ${monster.description}`);
                return;
            }
            // Item if visible
            const item = this.itemManager.items.find(it => it.x === x && it.y === y && this.visible[it.y][it.x]);
            if (item) {
                this.addMessage(`${item.name}: ${item.description || 'An indescribable object.'}`);
                return;
            }
            // Tile description
            const tile = this.dungeon[y][x];
            let tilDesc = '';
            switch (tile) {
                case '#':
                    tilDesc = 'A rough-hewn stone wallâ€”unyielding.';
                    break;
                case '.':
                    tilDesc = 'Open dungeon floor, strewn with dust and echoes.';
                    break;
                case '+':
                    tilDesc = 'A closed wooden door; hinges creak with potential.';
                    break;
                case '/':
                    tilDesc = 'An open doorway leading into shadow.';
                    break;
                case '<':
                    tilDesc = 'A stairwell spiraling upward.';
                    break;
                case '>':
                    tilDesc = 'Steps descending into deeper peril.';
                    break;
                default:
                    tilDesc = 'Featureless dark.';
                    break;
            }
            if (verbose) this.addMessage(tilDesc);
            else this.addMessage(tilDesc);
        }

        // Toggle between inventory and stats sidebar views
        toggleSidebarView() {
            this.sidebarShowingInventory = !this.sidebarShowingInventory;
            const inventorySection = document.getElementById('inventorySection');
            const statsSection = document.getElementById('statsSection');
            if (!inventorySection || !statsSection) return;
            if (this.sidebarShowingInventory) {
                inventorySection.style.display = 'block';
                statsSection.style.display = 'none';
                // Rebuild inventory when switching back
                this.buildInventory();
            } else {
                inventorySection.style.display = 'none';
                statsSection.style.display = 'block';
            }
        }

        // Restored inventory UI construction
        buildInventory() {
            const container = document.getElementById('inventoryContents');
            if (!container) return;
            const p = Game.player;
            const lines = [];

            // Equipped section
            lines.push(`<div class='equipped-section'>`);
            lines.push(`<h4>Currently Equipped</h4>`);
            lines.push(`<div class='equipped-grid'>`);
            const renderSlot = (bodyPart) => {
                const item = bodyPart.equipped;
                const hasItem = item && !(item instanceof EmptyItem);
                const slotClass = hasItem ? 'equipped-slot has-item' : 'equipped-slot';
                const itemText = hasItem ? item.name : 'None';
                const itemClass = hasItem ? 'slot-item' : 'slot-item slot-empty';
                const unequipButton = (hasItem && !(item instanceof Fists)) ? `<div class='slot-actions'><button onclick="game.unequipSlot('${bodyPart.name}', '${item.name}')">Remove</button></div>` : '';
                return `<div class='${slotClass}'>
                    <span class='slot-label'>${bodyPart.name}:</span>
                    <span class='${itemClass}'>${itemText}</span>
                    ${unequipButton}
                </div>`;
            };
            lines.push(renderSlot(p.body.weapon));
            lines.push(renderSlot(p.body.head));
            lines.push(renderSlot(p.body.torso));
            lines.push(renderSlot(p.body.arms));
            lines.push(renderSlot(p.body.hands));
            lines.push(renderSlot(p.body.finger));
            lines.push(renderSlot(p.body.legs));
            lines.push(renderSlot(p.body.feet));
            lines.push('</div></div>');

            const section = (title, arr, renderFn) => {
                if (!arr || !arr.length) return;
                lines.push(`<div class='inv-section'><h4>${title}</h4>`);
                arr.forEach((item, idx) => lines.push(renderFn(item, idx)));
                lines.push('</div>');
            };
            lines.push(`<div class='inv-section'><div>Gold: ${p.inventory.gold}</div></div>`);
            section('Potions', p.inventory.potions, (it, i) => this.renderInvRow('potions', it, i));
            section('Scrolls', p.inventory.scrolls, (it, i) => this.renderInvRow('scrolls', it, i));
            section('Weapons', p.inventory.weapons, (it, i) => this.renderInvRow('weapons', it, i, p.equippedWeapon() === it));
            section('Armor', p.inventory.armor, (it, i) => this.renderInvRow('armor', it, i, p.equippedArmor().includes(it)));
            container.innerHTML = lines.join('');
        }

        renderInvRow(category, item, index, equipped = false) {
            const tags = [];
            if (equipped) tags.push('<span class="tag">Eq</span>');
            if (category === 'weapons') tags.push(`<span class='tag'>+${item.getDamage()} atk</span>`);
            if (category === 'armor') tags.push(`<span class='tag'>+${item.defense} def</span>`);
            if (category === 'potions') {
                if (item.healAmount) tags.push(`<span class='tag'>+${item.healAmount} HP</span>`);
                if (item.count > 1) tags.push(`<span class='tag'>x${item.count}</span>`);
            }
            if (category === 'scrolls') {
                if (item.count > 1) tags.push(`<span class='tag'>x${item.count}</span>`);
            }
            let actionButtons = '';
            if (category === 'weapons' && !(item instanceof Fists)) {
                actionButtons += equipped ? `<button onclick="game.unequipInventoryItem('weapons')">Unequip</button>` : `<button onclick="game.equipInventoryItem('weapons',${index})">Equip</button>`;
            }
            if (category === 'armor') {
                actionButtons += equipped ? `<button onclick="game.unequipInventoryItem('armor')">Unequip</button>` : `<button onclick="game.equipInventoryItem('armor',${index})">Equip</button>`;
            }
            if (category === 'potions') actionButtons += `<button onclick="game.useInventoryItem('potions',${index})">Drink</button>`;
            if (category === 'scrolls') actionButtons += `<button onclick="game.useInventoryItem('scrolls',${index})">Cast</button>`;
            actionButtons += `<button onclick="Game.player.dropInventoryItem('${category}',${index})">Drop</button>`;
            return `<div class='inv-item-row'><div style='flex:1 1 auto;'>${item.name || 'Unknown'} ${tags.join(' ')}</div><div class='inv-actions'>${actionButtons}</div></div>`;
        }

        equipInventoryItem(category, index) {
            if (category === 'weapons') {
                const w = Game.player.inventory.weapons[index];
                if (!w) return;
                Game.player.equipWeapon(w);
                this.addMessage(`You equip ${w.name}.`);
            } else if (category === 'armor') {
                const a = Game.player.inventory.armor[index];
                if (!a) return;
                Game.player.equipArmor(a);
                this.addMessage(`You don ${a.name}.`);
            }
            this.buildInventory();
            this.updateUI();
        }

        unequipInventoryItem(category) {
            if (category === 'weapons' && Game.player.equippedWeapon()) {
                this.addMessage(`You stow ${Game.player.equippedWeapon().name}.`);
                Game.player.unEquipWeapon();
            }
            if (category === 'armor') {
                const equipped = Game.player.equippedArmor();
                equipped.forEach(a => {
                    this.addMessage(`You remove ${a.name}.`);
                    Game.player.unEquipArmor(a.bodyLocation);
                });
            }
            this.buildInventory();
            this.updateUI();
        }

        unequipSlot(bodyPartName) {
            const p = Game.player;
            if (bodyPartName === 'weapon') {
                const weapon = p.body.weapon.equipped;
                if (weapon && !(weapon instanceof EmptyItem) && !(weapon instanceof Fists)) {
                    this.addMessage(`You stow ${weapon.name}.`);
                    p.unEquipWeapon();
                }
            } else if (p.body[bodyPartName]) {
                const item = p.body[bodyPartName].equipped;
                if (item && !(item instanceof EmptyItem)) {
                    this.addMessage(`You remove ${item.name}.`);
                    p.unEquipArmor(bodyPartName);
                }
            }
            this.buildInventory();
            this.updateUI();
        }

        useInventoryItem(category, index) {
            const p = Game.player;
            const arr = p.inventory[category];
            if (!arr || !arr[index]) {
                this.addMessage('Nothing to use.');
                return;
            }
            const item = arr[index];
            if (category === 'potions') {
                if (typeof item.use === 'function') {
                    const result = item.use(this);
                    if (result && result.message) this.addMessage(result.message);
                } else {
                    const healAmount = item.healAmount || 20;
                    const actualHeal = p.heal(healAmount);
                    this.addMessage(`You drink ${item.name} (+${actualHeal} HP).`);
                }
                item.count -= 1;
                if (item.count <= 0) arr.splice(index, 1);
                this.consumeTurn(20);
            } else if (category === 'scrolls') {
                if (typeof item.use === 'function') {
                    this.addMessage(`You read the ${item.name}.`);
                    item.use(this);
                } else {
                    const targets = this.monsterManager.monsters.filter(m => this.visible[m.y] && this.visible[m.y][m.x]);
                    if (targets.length) {
                        const damage = item.damage || 10;
                        let killed = 0;
                        targets.forEach(m => {
                            m.hp -= damage;
                            if (m.hp <= 0) killed++;
                        });
                        if (killed) this.monsterManager.monsters = this.monsterManager.monsters.filter(m => m.hp > 0);
                        this.addMessage(`You cast ${item.name}. ${targets.length} hit, ${killed} slain.`);
                    } else this.addMessage(`You cast ${item.name}, but there are no targets in sight.`);
                }
                item.count -= 1;
                if (item.count <= 0) arr.splice(index, 1);
                this.consumeTurn(30);
            }
            this.buildInventory();
            this.updateUI();
            this.render();
        }

        handleMove(dx, dy) {
            const nx = Game.player.x + dx, ny = Game.player.y + dy;
            if (nx < 0 || ny < 0 || nx >= this.width || ny >= this.height) return;
            if (this.dungeon[ny][nx] === '+') {
                this.dungeon[ny][nx] = '/';
                this.addMessage('You open the door.');
                this.consumeTurn(20);
                return;
            }
            const monster = this.monsterManager.monsters.find(m => m.x === nx && m.y === ny);
            if (monster) {
                const result = Game.player.attemptAttack(monster);
                if (result.hit) this.monsterManager.attackMonster(monster); else this.addMessage('You miss!');
                return;
            }
            if (this.isValidMove(nx, ny)) {
                Game.player.x = nx;
                Game.player.y = ny;
                this.itemManager.checkForItems();
                this.consumeTurn(Game.player.speed);
            }
        }

        isValidMove(x, y) {
            if (x < 0 || y < 0 || x >= this.width || y >= this.height) return false;
            const t = this.dungeon[y][x];
            return t === '.' || t === '/' || t === '<' || t === '>';
        }

        openAdjacentDoors() {
            let opened = 0;
            const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dx, dy] of dirs) {
                const x = Game.player.x + dx, y = Game.player.y + dy;
                if (!this.inBounds(x, y)) continue;
                if (this.dungeon[y][x] === '+') {
                    this.dungeon[y][x] = '/';
                    opened++;
                }
            }
            if (opened) {
                this.addMessage(`You open ${opened} door${opened > 1 ? 's' : ''}.`);
                this.consumeTurn(20);
            } else this.addMessage('No closed door adjacent.');
        }

        closeAdjacentDoors() {
            let closed = 0;
            const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dx, dy] of dirs) {
                const x = Game.player.x + dx, y = Game.player.y + dy;
                if (!this.inBounds(x, y)) continue;
                if (this.dungeon[y][x] === '/') {
                    this.dungeon[y][x] = '+';
                    closed++;
                }
            }
            if (closed) {
                this.addMessage(`You close ${closed} door${closed > 1 ? 's' : ''}.`);
                this.consumeTurn(20);
            } else this.addMessage('No closed door adjacent.');
        }

        useDownStairs() {
            if (this.gameOver) return;
            if (this.downStair && Game.player.x === this.downStair.x && Game.player.y === this.downStair.y) {
                this.descend();
                return;
            }
            this.addMessage('There are no stairs here.');
        }

        useUpStairs() {
            if (this.gameOver) return;
            if (this.upStair && Game.player.x === this.upStair.x && Game.player.y === this.upStair.y) {
                this.ascend();
                return;
            }
            this.addMessage('There are no stairs here.');
        }

        consumeTurn(ticksToConsume = 100) {
            for (let i = 0; i < ticksToConsume; i++) {
                this.computeFOV();
                this.timeManager.advanceTime();
                this.computeFOV();
                this.render();
                this.updateUI();
            }
        }

        render() {
            const ts = this.tileSize;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for (let y = 0; y < this.height; y++) {
                for (let x = 0; x < this.width; x++) {
                    if (!this.explored[y][x]) continue;
                    const tile = this.dungeon[y][x];
                    const px = x * ts, py = y * ts;
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(px, py, ts, ts);
                    this.ctx.font = '16px monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    let char = tile, color = '#888';
                    if (tile === '#') color = '#777'; else if (tile === '.') color = '#555'; else if (tile === '+') {
                        char = '+';
                        color = '#aa7722';
                    } else if (tile === '/') {
                        char = '/';
                        color = '#ddbb77';
                    }
                    this.ctx.fillStyle = color;
                    this.ctx.fillText(char, px + ts / 2, py + ts / 2);
                }
            }
            const drawStair = (stair, symbol, color) => {
                if (!stair) return;
                const {x, y} = stair;
                if (!this.explored[y][x]) return;
                const px = x * ts, py = y * ts;
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(px, py, ts, ts);
                this.ctx.font = '16px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = color;
                this.ctx.fillText(symbol, px + ts / 2, py + ts / 2);
            };
            drawStair(this.upStair, '<', '#88ff88');
            drawStair(this.downStair, '>', '#ff8888');
            this.itemManager.items.forEach(it => {
                if (!this.visible[it.y][it.x]) return;
                const px = it.x * ts, py = it.y * ts;
                this.ctx.font = '16px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = it.getColor ? (it.getColor() || '#fff') : '#fff';
                this.ctx.fillText(it.getSymbol ? it.getSymbol() : '?', px + ts / 2, py + ts / 2);
            });
            this.itemManager.itemMemory.forEach((mem, key) => {
                const [xs, ys] = key.split(',').map(Number);
                if (this.visible[ys] && this.visible[ys][xs]) return;
                if (!this.explored[ys][xs]) return;
                const px = xs * ts, py = ys * ts;
                this.ctx.font = '16px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                const memColors = {
                    gold: '#666600',
                    potion: '#662266',
                    scroll: '#006666',
                    weapon: '#663333',
                    armor: '#333366'
                };
                this.ctx.fillStyle = memColors[mem.type] || '#555';
                this.ctx.fillText(mem.symbol, px + ts / 2, py + ts / 2);
            });
            for (const m of this.monsterManager.monsters) {
                if (!this.visible[m.y] || !this.visible[m.y][m.x]) continue;
                const px = m.x * ts, py = m.y * ts;
                this.ctx.font = '16px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = m.getColor();
                this.ctx.fillText(m.getSymbol(), px + ts / 2, py + ts / 2);
            }
            const ppx = Game.player.x * ts, ppy = Game.player.y * ts;
            this.ctx.font = '16px monospace';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillStyle = this.gameOver ? '#ff0000' : '#00ff00';
            this.ctx.fillText('@', ppx + ts / 2, ppy + ts / 2);
            // Examine cursor highlight
            if (this.examineMode && this.examineCursor) {
                const cx = this.examineCursor.x * ts;
                const cy = this.examineCursor.y * ts;
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(cx + 1, cy + 1, ts - 2, ts - 2);
            }
        }

        canDropHere() {
            const x = Game.player.x, y = Game.player.y;
            if (!this.inBounds(x, y)) return false;
            const t = this.dungeon[y][x];
            if (!(t === '.' || t === '/' || t === '<' || t === '>')) return false;
            return !this.itemManager.items.some(it => it.x === x && it.y === y);
        }

        instantiateDroppedItem(item, x, y) {
            const ctorName = item.constructor && item.constructor.name;
            try {
                switch (ctorName) {
                    case 'HealthPotion':
                        return new HealthPotion(x, y, item.name, item.healAmount);
                    case 'SpeedPotion':
                        return new SpeedPotion(x, y, item.name, item.speedBoost);
                    case 'Potion':
                        return new Potion(x, y, item.name, item.healAmount);
                    case 'PsionicScroll':
                        return new PsionicScroll(x, y, item.name, item.damage);
                    case 'TeleportScroll':
                        return new TeleportScroll(x, y);
                    case 'MappingScroll':
                        return new MappingScroll(x, y);
                    case 'FireballScroll':
                        return new FireballScroll(x, y, item.damage, item.radius);
                    case 'RegenerationScroll':
                        return new RegenerationScroll(x, y, item.totalHeals, item.healPerTick, item.interval);
                    case 'Scroll':
                        return new Scroll(x, y, item.name, item.damage);
                    default:
                        return null;
                }
            } catch (e) {
                console.error('instantiateDroppedItem error', e);
                return null;
            }
        }

        updateUI() {
            document.getElementById('level').textContent = Game.player.level;
            document.getElementById('health').textContent = Game.player.health;
            document.getElementById('gold').textContent = Game.player.inventory.gold;
            this.buildInventory();
        }

        addMessage(msg) {
            const box = document.getElementById('messages');
            const div = document.createElement('div');
            div.textContent = msg;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
            while (box.children.length > 20) box.removeChild(box.firstChild);
        }

        sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    let game;
    window.addEventListener('load', () => {
        game = new Game();
    });
</script>
</body>
</html>
